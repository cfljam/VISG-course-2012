.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::NSP::Measures::2D 3"
.TH Text::NSP::Measures::2D 3 "2008-03-27" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Text::NSP::Measures::2D \- Perl module that provides basic framework
                          for building measure of association for
                          bigrams.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\fIBasic Usage\fR
.IX Subsection "Basic Usage"
.PP
.Vb 1
\& use Text::NSP::Measures::2D::MI::ll;
.Ve
.PP
.Vb 1
\&  my $npp = 60; my $n1p = 20; my $np1 = 20;  my $n11 = 10;
.Ve
.PP
.Vb 4
\&  $ll_value = calculateStatistic( n11=>$n11,
\&                                      n1p=>$n1p,
\&                                      np1=>$np1,
\&                                      npp=>$npp);
.Ve
.PP
.Vb 8
\&  if( ($errorCode = getErrorCode()))
\&  {
\&    print STDERR $errorCode." - ".getErrorMessage()."\en"";
\&  }
\&  else
\&  {
\&    print getStatisticName."value for bigram is ".$ll_value."\en"";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is to be used as a foundation for building 2\-dimensional
measures of association. The methods in this module retrieve observed
bigram frequency counts, marginal totals, and also compute expected
values. They also provide error checks for these counts.
.PP
With bigram or 2d measures we use variables with corresponding names
to store the 2x2 contingency table to store the frequency counts
associated with each word in the bigram, as well as the number of
times the bigram occurs. A contingency table looks like
.PP
.Vb 6
\&            |word2  | not-word2|
\&            --------------------
\&    word1   | n11   |   n12    |  n1p
\&  not-word1 | n21   |   n22    |  n2p
\&            --------------------
\&              np1       np2       npp
.Ve
.PP
Marginal Frequencies:
.PP
.Vb 4
\&  n1p = the number of bigrams where the first word is word1.
\&  np1 = the number of bigrams where the second word is word2.
\&  n2p = the number of bigrams where the first word is not word1.
\&  np2 = the number of bigrams where the second word is not word2.
.Ve
.PP
.Vb 3
\&  These marginal totals are stored in variables which have names
\&  corresponding to the cell they represent. These values may then be
\&  referred to as follows:
.Ve
.PP
.Vb 5
\&        $n1p,
\&        $np1,
\&        $n2p,
\&        $np2,
\&        $npp
.Ve
.PP
Observed Frequencies:
.PP
.Vb 7
\&  n11 = number of times the bigram occurs, joint frequency
\&  n12 = number of times word1 occurs in the first position of a bigram
\&        when word2 does not occur in the second position.
\&  n21 = number of times word2 occurs in the second position of a
\&        bigram when word1 does not occur in the first position.
\&  n22 = number of bigrams where word1 is not in the first position and
\&        word2 is not in the second position.
.Ve
.PP
.Vb 2
\&  The observed frequencies are also stored in variables with corresponding names.
\&  These values may then be referred to as follows:
.Ve
.PP
.Vb 4
\&        $n11,
\&        $n12,
\&        $n21,
\&        $n22
.Ve
.PP
Expected Frequencies:
.PP
.Vb 11
\&  m11 = expected number of times both words in the bigram occur
\&        together if they are independent. (n1p*np1/npp)
\&  m12 = expected number of times word1 in the bigram will occur in
\&        the first position when word2 does not occur in the second
\&        position given that the words are independent. (n1p*np2/npp)
\&  m21 = expected number of times word2 in the bigram will occur
\&        in the second position when word1 does not occur in the first
\&        position given that the words are independent. (np1*n2p/npp)
\&  m22 = expected number of times word1 will not occur in the first
\&        position and word2 will not occur in the second position
\&        given that the words are independent. (n2p*np2/npp)
.Ve
.PP
.Vb 1
\&  Similarly the expected values are stored as
.Ve
.PP
.Vb 4
\&        $m11,
\&        $m12,
\&        $m21,
\&        $m22
.Ve
.Sh "Methods"
.IX Subsection "Methods"
.IP "\fIcomputeObservedValues()\fR \- A method to compute observed values, and also to verify that the computed Observed values are correct, That is they are positive, less than the marginal totals and the total bigram count." 4
.IX Item "computeObservedValues() - A method to compute observed values, and also to verify that the computed Observed values are correct, That is they are positive, less than the marginal totals and the total bigram count."
\&\s-1INPUT\s0 \s-1PARAMS\s0  : \f(CW$count_values\fR     .. Reference to an hash consisting
                                     of the count values passed to
                                     the \fIcalculateStatistic()\fR method.
.Sp
\&\s-1RETURN\s0 \s-1VALUES\s0 : 1/undef           ..returns '1' to indicate success
                                    and an undefined(\s-1NULL\s0) value to indicate
                                    failure.
=cut
.Sp
sub computeObservedValues
{
  my ($values) = \f(CW@_\fR;
.Sp
.Vb 17
\&  if(!defined $values->{n11})
\&  {
\&    $errorMessage = "Required frequency count (1,1) not passed";
\&    $errorCodeNumber = 200;
\&    return;
\&  }
\&  else
\&  {
\&    $n11 = $values->{n11};
\&  }
\&  # joint frequency should be greater than equal to zero
\&  if ($n11 < 0)
\&  {
\&    $errorMessage = "Frequency value 'n11' must not be negative.";
\&    $errorCodeNumber = 201;
\&    return;
\&  }
.Ve
.Sp
.Vb 8
\&  # joint frequency (n11) should be less than or equal to the
\&  # total number of bigrams (npp)
\&  if($n11 > $npp)
\&  {
\&    $errorMessage = "Frequency value 'n11' must not exceed total number of bigrams.";
\&    $errorCodeNumber = 202;
\&    return;
\&  }
.Ve
.Sp
.Vb 7
\&  # joint frequency should be less than or equal to the marginal totals
\&  if ($n11 > $np1 || $n11 > $n1p)
\&  {
\&    $errorMessage = "Frequency value of ngram 'n11' must not exceed the marginal totals.";
\&    $errorCodeNumber = 202;
\&    return;
\&  }
.Ve
.Sp
.Vb 5
\&  #  The marginal totals are reasonable so we can
\&  #  calculate the observed frequencies
\&  $n12 = $n1p - $n11;
\&  $n21 = $np1 - $n11;
\&  $n22 = $np2 - $n12;
.Ve
.Sp
.Vb 6
\&  if ($n12 < 0)
\&  {
\&    $errorMessage = "Frequency value 'n12' must not be negative.";
\&    $errorCodeNumber = 201;
\&    return;
\&  }
.Ve
.Sp
.Vb 6
\&  if ($n21 < 0)
\&  {
\&    $errorMessage = "Frequency value 'n21' must not be negative.";
\&    $errorCodeNumber = 201;
\&    return;
\&  }
.Ve
.Sp
.Vb 6
\&  if ($n22 < 0)
\&  {
\&    $errorMessage = "Frequency value 'n22' must not be negative.";
\&    $errorCodeNumber = 201;
\&    return;
\&  }
.Ve
.Sp
.Vb 2
\&  return 1;
\&}
.Ve
.IP "\fIcomputeExpectedValues()\fR \- A method to compute expected values." 4
.IX Item "computeExpectedValues() - A method to compute expected values."
\&\s-1INPUT\s0 \s-1PARAMS\s0  :none
.Sp
\&\s-1RETURN\s0 \s-1VALUES\s0 : 1/undef           ..returns '1' to indicate success
                                    and an undefined(\s-1NULL\s0) value to indicate
                                    failure.
.IP "\fIcomputeMarginalTotals()\fR \- This method computes the marginal totals from the count values as passed to it." 4
.IX Item "computeMarginalTotals() - This method computes the marginal totals from the count values as passed to it."
\&\s-1INPUT\s0 \s-1PARAMS\s0  : \f(CW$count_values\fR     .. Reference to an hash consisting
                                     of the frequency combination
                                     output.
.Sp
\&\s-1RETURN\s0 \s-1VALUES\s0 : 1/undef           ..returns '1' to indicate success
                                    and an undefined(\s-1NULL\s0) value to indicate
                                    failure.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ted Pedersen,                University of Minnesota Duluth
                             <tpederse@d.umn.edu>
.PP
Satanjeev Banerjee,          Carnegie Mellon University
                             <satanjeev@cmu.edu>
.PP
Amruta Purandare,            University of Pittsburgh
                             <amruta@cs.pitt.edu>
.PP
Bridget Thomson\-McInnes,     University of Minnesota Twin Cities
                             <bthompson@d.umn.edu>
.PP
Saiyam Kohli,                University of Minnesota Duluth
                             <kohli003@d.umn.edu>
.SH "HISTORY"
.IX Header "HISTORY"
Last updated: \f(CW$Id:\fR 2D.pm,v 1.28 2008/03/26 17:25:13 tpederse Exp $
.SH "BUGS"
.IX Header "BUGS"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://groups.yahoo.com/group/ngram/>
.PP
<http://www.d.umn.edu/~tpederse/nsp.html>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-2006, Ted Pedersen, Satanjeev Banerjee,
Amruta Purandare, Bridget Thomson-McInnes and Saiyam Kohli
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.
.PP
This program is distributed in the hope that it will be useful, but
\&\s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0
General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program; if not, write to
.PP
.Vb 3
\&    The Free Software Foundation, Inc.,
\&    59 Temple Place - Suite 330,
\&    Boston, MA  02111-1307, USA.
.Ve
.PP
Note: a copy of the \s-1GNU\s0 General Public License is available on the web
at <http://www.gnu.org/licenses/gpl.txt> and is included in this
distribution as \s-1GPL\s0.txt.
