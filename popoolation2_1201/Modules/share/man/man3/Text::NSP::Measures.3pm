.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::NSP::Measures 3"
.TH Text::NSP::Measures 3 "2008-03-27" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Text::NSP::Measures \- Perl modules for computing association scores of
                      Ngrams. This module provides the basic framework
                      for these measures.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Sh "Basic Usage"
.IX Subsection "Basic Usage"
.Vb 1
\&  use Text::NSP::Measures::2D::MI::ll;
.Ve
.PP
.Vb 1
\&  my $npp = 60; my $n1p = 20; my $np1 = 20;  my $n11 = 10;
.Ve
.PP
.Vb 4
\&  $ll_value = calculateStatistic( n11=>$n11,
\&                                      n1p=>$n1p,
\&                                      np1=>$np1,
\&                                      npp=>$npp);
.Ve
.PP
.Vb 8
\&  if( ($errorCode = getErrorCode()))
\&  {
\&    print STDERR $errorCode." - ".getErrorMessage()."\en"";
\&  }
\&  else
\&  {
\&    print getStatisticName."value for bigram is ".$ll_value."\en"";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Introduction"
.IX Subsection "Introduction"
These modules provide perl implementations of mathematical functions
(association measures) that can be used to interpret the co-occurrence
frequency data for Ngrams. We define an Ngram as a sequence of 'n'
tokens that occur within a window of at least 'n' tokens in the text;
what constitutes a \*(L"token\*(R" can be defined by the user.
.PP
The measures that have been implemented in this distribution are:
.IP "1) \s-1MI\s0 (Mutual Information based Measures)" 4
.IX Item "1) MI (Mutual Information based Measures)"
.RS 4
.PD 0
.IP "a) Loglikelihood (for Bigrams and Trigrams)" 4
.IX Item "a) Loglikelihood (for Bigrams and Trigrams)"
.IP "b) True Mutual Information (for Bigrams and Trigrams)" 4
.IX Item "b) True Mutual Information (for Bigrams and Trigrams)"
.IP "c) Pointwise Mutual Information (for Bigrams and Trigrams)" 4
.IX Item "c) Pointwise Mutual Information (for Bigrams and Trigrams)"
.IP "d) Poisson Stirling Measure (for Bigrams and Trigrams)" 4
.IX Item "d) Poisson Stirling Measure (for Bigrams and Trigrams)"
.RE
.RS 4
.RE
.IP "2) \s-1CHI\s0 (Measures belonging to the \s-1CHI\s0 family)" 4
.IX Item "2) CHI (Measures belonging to the CHI family)"
.RS 4
.IP "a) Chi-squared Measure" 4
.IX Item "a) Chi-squared Measure"
.IP "b) Phi Coefficient" 4
.IX Item "b) Phi Coefficient"
.IP "c) T\-Score" 4
.IX Item "c) T-Score"
.RE
.RS 4
.RE
.IP "3) Dice (Measures belonging to the Dice family)" 4
.IX Item "3) Dice (Measures belonging to the Dice family)"
.RS 4
.IP "a) Dice Coefficient" 4
.IX Item "a) Dice Coefficient"
.IP "b) Jaccard Measure" 4
.IX Item "b) Jaccard Measure"
.RE
.RS 4
.RE
.IP "4) Fishers Exact Tests" 4
.IX Item "4) Fishers Exact Tests"
.RS 4
.IP "a) Left Fishers Exact Test" 4
.IX Item "a) Left Fishers Exact Test"
.IP "b) Right Fishers Exact Test" 4
.IX Item "b) Right Fishers Exact Test"
.IP "c) Two-Tailed Fishers Exact Test" 4
.IX Item "c) Two-Tailed Fishers Exact Test"
.RE
.RS 4
.RE
.IP "5) Odds Ratio" 4
.IX Item "5) Odds Ratio"
.PD
.PP
Further discussion about these measures is in their respective
documentations.
.Sh "Writing your own association measures"
.IX Subsection "Writing your own association measures"
This module also provides a basic framework for building new measures
of association for Ngrams. The new Measure should either inherit from
Text::NSP::Measures::2D or Text::NSP::Measures::3D modules, depending
on whether it is a bigram or a trigram measure. Both these modules
implement methods that retrieve observed frequency counts, marginal
totals, and also compute expected values. They also provide error
checks for these counts.
.PP
You can either write your new measure as a new module, or you can
simply write a perl program. Here we will describe how to write a
new measure as a perl module Perl.
.IP "1" 4
.IX Item "1"
To create a new Perl module for the measure issue the following
command (replace 'NewMeasure' with the name of your measure):
.RS 4
.Sp
.RS 4
h2xs \-AXc \-n Text::NSP::Measures::2D::NewMeasure
(for bigram measures)
.Sp
.Vb 1
\&                      or
.Ve
.Sp
h2xs \-AXc \-n Text::NSP::Measures::3D::NewMeasure
(for trigram measures)
.RE
.RE
.RS 4
.Sp
This will create a new folder namely...
.Sp
.RS 4
Text\-NSP\-Measures\-2D\-NewMeasure (for bigram)
.Sp
.Vb 1
\&            or
.Ve
.Sp
Text\-NSP\-Measures\-3D\-NewMeasure (for trigram)
.RE
.RE
.RS 4
.Sp
This will create an empty framework for the new association measure.
Once you are done completing the changes you will have to install the
module before you can use it.
.Sp
To make changes to the module open:
.Sp
.RS 4
Text\-NSP\-Measures\-2D\-NewMeasure/lib/Text/NSP/Measures/2D/NewMeasure/
NewMeasure.pm
.Sp
.Vb 1
\&                        or
.Ve
.Sp
Text\-NSP\-Measures\-3D\-NewMeasure/lib/Text/NSP/Measures/3D/NewMeasure/
NewMeasure.pm
.RE
.RE
.RS 4
.Sp
in your favorite text editor, and do as follows.
.RE
.IP "2" 4
.IX Item "2"
Let us say you have named your module NewMeasure. The first line of
the file should declare that it is a package. Thus the first line of
the file NewMeasure.pm should be...
.RS 4
.Sp
.RS 4
package Text::NSP::Measures::2D::NewMeasure; (for bigram measures)
.Sp
.Vb 1
\&                  or
.Ve
.Sp
package Text::NSP::Measures::3D::NewMeasure; (for trigram measures)
.RE
.RE
.RS 4
.Sp
To inherit the functionality from the 2D or 3D module you need to
include it in your NewMeasure.pm module.
.Sp
A small code snippet to ensure that it is included is as follows:
.IP "1 For Bigrams" 4
.IX Item "1 For Bigrams"
use Text::NSP::Measures::2D::MI;
.IP "2 For Trigrams" 4
.IX Item "2 For Trigrams"
use Text::NSP::Measures::2D::MI;
.RE
.RS 4
.Sp
You also need to insert the following lines to make sure that the required
functions are visible to the programs using your module. These lines are
same for bigrams and trigrams. The \*(L"no warnings 'redefine';\*(R" statement is
used to suppress perl warnings about method overriding.
.Sp
.RS 4
use strict;
use Carp;
use warnings;
no warnings 'redefine';
require Exporter;
.Sp
our ($VERSION, \f(CW@EXPORT\fR, \f(CW@ISA\fR);
.Sp
@ISA  = qw(Exporter);
.Sp
@EXPORT = qw(initializeStatistic calculateStatistic
             getErrorCode getErrorMessage getStatisticName);
.RE
.RE
.RS 4
.RE
.IP "3 You need to implement at least one method in your package" 4
.IX Item "3 You need to implement at least one method in your package"
.RS 4
.PD 0
.IP "i)  \fIcalculateStatistic()\fR" 4
.IX Item "i)  calculateStatistic()"
.RE
.RS 4
.PD
.Sp
This method is passed reference to a hash containing the
frequency values for a Ngram as found in the input Ngram file.
.Sp
method \fIcalculateStatistic()\fR is expected to return a (possibly
floating point) value as the value of the statistical measure calculated
using the frequency values passed to it.
.Sp
There exist three methods in the modules Text::NSP::Measures::2d and
Text::NSP::Measures::3D in order to help calculate the ngram
statistic.
.IP "1.  computeMarginalTotals($frequencies);" 4
.IX Item "1.  computeMarginalTotals($frequencies);"
.PD 0
.IP "2.  computeObservedValues($frequencies);" 4
.IX Item "2.  computeObservedValues($frequencies);"
.IP "3.  computeExpectedValues($frequencies);" 4
.IX Item "3.  computeExpectedValues($frequencies);"
.RE
.RS 4
.PD
.Sp
These methods return the observed and expected values of the cells in
the contingency table. A 2D contingency table looks like:
.Sp
.Vb 6
\&            |word2  | not-word2|
\&            --------------------
\&    word1   | n11   |   n12    |  n1p
\&  not-word1 | n21   |   n22    |  n2p
\&            --------------------
\&              np1       np2       npp
.Ve
.Sp
Here the marginal totals are np1, n1p, np2, n2p, the Observed values
are n11, n12, n21, n22 and the expected values for the corresponding
observed values are represented using m11, m12, m21, m22, here m11
represents the expected value for the cell (1,1), m12 for the cell
(1,2) and so on.
.Sp
Before calling either \fIcomputeObservedValues()\fR or \fIcomputeExpectedValues()\fR
you \s-1MUST\s0 call \fIcomputeMarginalTotals()\fR, since these methods require the
marginal to be set. The computeMarginalTotals method computes the marginal
totals in the contingency table based on the observed frequencies. It
returns an undefined value in case of some error. In case success it
returns '1'. An example of usage for the \fIcomputeMarginalTotals()\fR method is
.Sp
.RS 4
my \f(CW%values\fR = \f(CW@_\fR;
.Sp
if(!(Text::NSP::Measures::2D::computeMarginalTotals(\e%values)) ){
  return;
}
.RE
.RE
.RS 4
.Sp
@_ is the parameters passed to calculateStatistic. After this call the
marginal totals will be available in the following variables
.ie n .IP "1. For bigrams $npp\fR , \f(CW$n1p\fR, \f(CW$np1\fR, \f(CW$n2p\fR, \f(CW$np2" 4
.el .IP "1. For bigrams \f(CW$npp\fR , \f(CW$n1p\fR, \f(CW$np1\fR, \f(CW$n2p\fR, \f(CW$np2\fR" 4
.IX Item "1. For bigrams $npp , $n1p, $np1, $n2p, $np2"
.PD 0
.ie n .IP "1. For trigrams $nppp\fR, \f(CW$n1pp\fR, \f(CW$np1p\fR, \f(CW$npp1\fR, \f(CW$n11p\fR, \f(CW$n1p1\fR, \f(CW$np11\fR, \f(CW$n2pp\fR, \f(CW$np2p\fR, \f(CW$npp2" 4
.el .IP "1. For trigrams \f(CW$nppp\fR, \f(CW$n1pp\fR, \f(CW$np1p\fR, \f(CW$npp1\fR, \f(CW$n11p\fR, \f(CW$n1p1\fR, \f(CW$np11\fR, \f(CW$n2pp\fR, \f(CW$np2p\fR, \f(CW$npp2\fR" 4
.IX Item "1. For trigrams $nppp, $n1pp, $np1p, $npp1, $n11p, $n1p1, $np11, $n2pp, $np2p, $npp2"
.RE
.RS 4
.PD
.Sp
\&\fIcomputeObservedValues()\fR computes the observed values of a ngram, It can be
called using the following code snippet. Please remember that you should call
\&\fIcomputeMarginalTotals()\fR before calling \fIcomputeObservedValues()\fR.
.Sp
.Vb 3
\&  if( !(Text::NSP::Measures::2D::computeObservedValues(\e%values)) ) {
\&      return;
\&  }
.Ve
.RE
.RS 4
.Sp
%value is the same hash that was initialized earlier for computeMarginalTotals.
.Sp
If successful it returns 1 otherwise an undefined value is returned. The
computed observed values will be available in the following variables:
.ie n .IP "1. For bigrams $n11\fR , \f(CW$n12\fR, \f(CW$n21\fR, \f(CW$n22" 4
.el .IP "1. For bigrams \f(CW$n11\fR , \f(CW$n12\fR, \f(CW$n21\fR, \f(CW$n22\fR" 4
.IX Item "1. For bigrams $n11 , $n12, $n21, $n22"
.PD 0
.ie n .IP "1. For trigrams $n111\fR, \f(CW$n112\fR, \f(CW$n121\fR, \f(CW$n122\fR, \f(CW$n211\fR, \f(CW$n212\fR, \f(CW$n221\fR, \f(CW$n222," 4
.el .IP "1. For trigrams \f(CW$n111\fR, \f(CW$n112\fR, \f(CW$n121\fR, \f(CW$n122\fR, \f(CW$n211\fR, \f(CW$n212\fR, \f(CW$n221\fR, \f(CW$n222\fR," 4
.IX Item "1. For trigrams $n111, $n112, $n121, $n122, $n211, $n212, $n221, $n222,"
.RE
.RS 4
.PD
.Sp
Similarly, \fIcomputeExpectedValues()\fR computes the expected values for each of
the cells in the contingency table. You should call \fIcomputeMarginalTotals()\fR
before calling \fIcomputeExpectedValues()\fR. The following code snippet
demonstrates its usage.
.Sp
.RS 4
if( !(\fIText::NSP::Measures::2D::computeExpectedValues()\fR) ) {
    return;
}
.RE
.RE
.RS 4
.Sp
If successful it returns 1 otherwise an undefined value is returned. The
computed expected values will be available in the following variables:
.ie n .IP "1. For bigrams $m11\fR , \f(CW$m12\fR, \f(CW$m21\fR, \f(CW$m22" 4
.el .IP "1. For bigrams \f(CW$m11\fR , \f(CW$m12\fR, \f(CW$m21\fR, \f(CW$m22\fR" 4
.IX Item "1. For bigrams $m11 , $m12, $m21, $m22"
.PD 0
.ie n .IP "1. For trigrams $m111\fR, \f(CW$m112\fR, \f(CW$m121\fR, \f(CW$m122\fR, \f(CW$m211\fR, \f(CW$m212\fR, \f(CW$m221\fR, \f(CW$m222," 4
.el .IP "1. For trigrams \f(CW$m111\fR, \f(CW$m112\fR, \f(CW$m121\fR, \f(CW$m122\fR, \f(CW$m211\fR, \f(CW$m212\fR, \f(CW$m221\fR, \f(CW$m222\fR," 4
.IX Item "1. For trigrams $m111, $m112, $m121, $m122, $m211, $m212, $m221, $m222,"
.RE
.RS 4
.RE
.IP "4" 4
.IX Item "4"
.PD
The last lines of a module should always return true, to achieve this
make sure that the last two lines of the are:
.Sp
.Vb 2
\&  1;
\&  __END__
.Ve
.Sp
Please see, that you can put in documentation after these lines.
.IP "5" 4
.IX Item "5"
There are four other methods that are not mandatory, but may be
implemented. These are:
.Sp
.Vb 4
\&     i) initializeStatistic()
\&    ii) getErrorCode
\&   iii) getErrorMessage
\&   iv) getStatisticName()
.Ve
.Sp
statistical.pl calls initializeStatistic before calling any
other method, if there is no need for any specific initialization
in the measure you need not define this method, and the
initialization will be handled by the Text::NSP::Measures modules
\&\fIinitializeStatistic()\fR method.
.Sp
The getErrorCode method is called immediately after every call to
method \fIcalculateStatistic()\fR. This method is used to return the
errorCode, if any, in the previous operations. To view all the
possible error codes and the corresponding error message please refer
to the Text::NSP documentation (perldoc Text::NSP).You can create new
error codes in your measure, if the existing error codes are not
sufficient.
.Sp
The Text::NSP::Measures module implements both \fIgetErrorCode()\fR
and \fIgetErrorMessage()\fR methods and these implementations of the method
will be invoked if the user does not define these methods. But if you
want to add some other actions that need to be performed in case
of an error you must override these methods by implementing them in
your module. You can invoke the Text::NSP::Measures \fIgetErrorCode()\fR
methods from your measures \fIgetErrorCode()\fR method.
.Sp
An example of this is below:
.Sp
.Vb 3
\&  sub getErrorCode
\&  {
\&    my $code = Text::NSP::Measures::getErrorCode();
.Ve
.Sp
.Vb 1
\&    #your code here
.Ve
.Sp
.Vb 2
\&    return $code; #(or any other value)
\&  }
.Ve
.Sp
.Vb 3
\&  sub getErrorMessage
\&  {
\&    my $message = Text::NSP::MeasuresgetErrorMessage();
.Ve
.Sp
.Vb 1
\&    #your code here
.Ve
.Sp
.Vb 2
\&    return $message; #(or any other value)
\&  }
.Ve
.Sp
The fourth method that may be implemented is \fIgetStatisticName()\fR.
If this method is implemented, it is expected to return a string
containing the name of the statistic being implemented. This string
is used in the formatted output of statistic.pl. If this method
is not implemented, then the statistic name entered on the
commandline is used in the formatted output.
.Sp
Note that all the methods described in this section are optional.
So, if the user elects to not implement these methods, no harm will
be done.
.Sp
The user may implement other methods too, but since statistic.pl is
not expecting anything besides the five methods above, doing so would
have no effect on statistic.pl.
.IP "6" 4
.IX Item "6"
You will need to install your module before you can use it. You can do
this by
.Sp
.Vb 2
\&  Change to the base directory for the module, i.e.
\&  NewMeasure
.Ve
.Sp
.Vb 1
\&  Then issue the following commands:
.Ve
.Sp
.Vb 4
\&    perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.Sp
.Vb 1
\&        or
.Ve
.Sp
.Vb 4
\&    perl Makefile.PL PREFIX=<destination directory>
\&    make
\&    make test
\&    make install
.Ve
.Sp
If you get any errors in the installation process, please make sure
that you have not made any syntactical error in your code and also
make sure that you have already installed the Text-NSP package.
.Sh "An Example"
.IX Subsection "An Example"
To tie it all together here is an example of a measure that computes
the sum of ngram frequency counts.
.Sp
.RS 4
package Text::NSP::Measures::2D::sum;
.Sp
use Text::NSP::Measures::2D::MI::2D;
use strict;
use Carp;
use warnings;
no warnings 'redefine';
require Exporter;
.Sp
our ($VERSION, \f(CW@EXPORT\fR, \f(CW@ISA\fR);
.Sp
@ISA  = qw(Exporter);
.Sp
@EXPORT = qw(initializeStatistic calculateStatistic
             getErrorCode getErrorMessage getStatisticName);
.Sp
$VERSION = '0.01';
.Sp
sub calculateStatistic
{
  my \f(CW%values\fR = \f(CW@_\fR;
.Sp
.Vb 6
\&  # computes and returns the marginal totals from the frequency
\&  # combination values. returns undef if there is an error in
\&  # the computation or the values are inconsistent.
\&  if(!(Text::NSP::Measures::2D::computeMarginalTotals($values)) ){
\&    return;
\&  }
.Ve
.Sp
.Vb 6
\&  # computes and returns the observed and marginal values from
\&  # the frequency combination values. returns 0 if there is an
\&  # error in the computation or the values are inconsistent.
\&  if( !(Text::NSP::Measures::2D::computeObservedValues($values)) ) {
\&      return;
\&  }
.Ve
.Sp
.Vb 2
\&  #  Now for the actual calculation of the association measure
\&  my $NewMeasure = 0;
.Ve
.Sp
.Vb 4
\&  $NewMeasure += $n11;
\&  $NewMeasure += $n12;
\&  $NewMeasure += $n21;
\&  $NewMeasure += $n22;
.Ve
.Sp
.Vb 2
\&  return ( $NewMeasure );
\&}
.Ve
.Sp
sub getStatisticName
{
  return \*(L"Sum\*(R";
}
.Sp
1;
_\|_END_\|_
.RE
.Sh "Errors to look out for:"
.IX Subsection "Errors to look out for:"
.IP "1" 4
.IX Item "1"
The Text-NSP package is not installed \- Make sure that Text-NSP
package is installed and you have inherited the correct module
(Text::NSP::Measures::2D or Text::NSP::Measures::3D).
.IP "2" 4
.IX Item "2"
The five methods (1 mandatory, 4 non\-mandatory) must have their
names match \s-1EXACTLY\s0 with those shown above. Again, names are all
case sensitive.
.IP "3" 4
.IX Item "3"
This statement is present at the end of the module:
1;
.Sh "Methods"
.IX Subsection "Methods"
.IP "\fIinitializeStatistic()\fR \- Provides an empty method which is called in case the measures do not override this method. If you need some measure specific initialization, override this method in the implementation of your measure." 4
.IX Item "initializeStatistic() - Provides an empty method which is called in case the measures do not override this method. If you need some measure specific initialization, override this method in the implementation of your measure."
\&\s-1INPUT\s0 \s-1PARAMS\s0  : none
.Sp
\&\s-1RETURN\s0 \s-1VALUES\s0 : none
.IP "\fIcalculateStatistic()\fR \- Provides an empty framework. Your Measure should override this method. \s-1INPUT\s0 \s-1PARAMS\s0  : none" 4
.IX Item "calculateStatistic() - Provides an empty framework. Your Measure should override this method. INPUT PARAMS  : none"
\&\s-1RETURN\s0 \s-1VALUES\s0 : none
.IP "\fIgetErrorCode()\fR \- Returns the error code in the last operation if any and resets the errorCode to 0." 4
.IX Item "getErrorCode() - Returns the error code in the last operation if any and resets the errorCode to 0."
# \s-1INPUT\s0 \s-1PARAMS\s0  : none
.Sp
# \s-1RETURN\s0 \s-1VALUES\s0 : errorCode  .. The current error code.
.IP "\fIgetErrorMessage()\fR \- Returns the error message in the last operation if any and resets the string to ''." 4
.IX Item "getErrorMessage() - Returns the error message in the last operation if any and resets the string to ''."
# \s-1INPUT\s0 \s-1PARAMS\s0  : none
.Sp
# \s-1RETURN\s0 \s-1VALUES\s0 : errorMessage  .. The current error message.
.IP "\fIgetStatisticName()\fR \- Provides an empty method which is called in case the measures do not override this method." 4
.IX Item "getStatisticName() - Provides an empty method which is called in case the measures do not override this method."
\&\s-1INPUT\s0 \s-1PARAMS\s0  : none
.Sp
\&\s-1RETURN\s0 \s-1VALUES\s0 : none
.SH "AUTHOR"
.IX Header "AUTHOR"
Ted Pedersen,                University of Minnesota Duluth
                             <tpederse@d.umn.edu>
.PP
Satanjeev Banerjee,          Carnegie Mellon University
                             <satanjeev@cmu.edu>
.PP
Amruta Purandare,            University of Pittsburgh
                             <amruta@cs.pitt.edu>
.PP
Bridget Thomson\-McInnes,     University of Minnesota Twin Cities
                             <bthompson@d.umn.edu>
.PP
Saiyam Kohli,                University of Minnesota Duluth
                             <kohli003@d.umn.edu>
.SH "HISTORY"
.IX Header "HISTORY"
Last updated: \f(CW$Id:\fR Measures.pm,v 1.15 2006/03/25 04:21:22 saiyam_kohli
Exp $
.SH "BUGS"
.IX Header "BUGS"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://groups.yahoo.com/group/Ngram/>
.PP
<http://www.d.umn.edu/~tpederse/nsp.html>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-2006, Ted Pedersen, Satanjeev Banerjee,
Amruta Purandare, Bridget Thomson-McInnes and Saiyam Kohli
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.
.PP
This program is distributed in the hope that it will be useful, but
\&\s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0
General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program; if not, write to
.PP
.Vb 3
\&    The Free Software Foundation, Inc.,
\&    59 Temple Place - Suite 330,
\&    Boston, MA  02111-1307, USA.
.Ve
.PP
Note: a copy of the \s-1GNU\s0 General Public License is available on the web
at <http://www.gnu.org/licenses/gpl.txt> and is included in this
distribution as \s-1GPL\s0.txt.
