.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::NSP::Measures::2D::Fisher2 3"
.TH Text::NSP::Measures::2D::Fisher2 3 "2008-03-27" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Text::NSP::Measures::2D::Fisher2 \- Perl module that provides methods
                                   to compute the Fishers exact tests.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\fIBasic Usage\fR
.IX Subsection "Basic Usage"
.PP
.Vb 1
\&  use Text::NSP::Measures::2D::Fisher2::left;
.Ve
.PP
.Vb 1
\&  my $npp = 60; my $n1p = 20; my $np1 = 20;  my $n11 = 10;
.Ve
.PP
.Vb 4
\&  $left_value = calculateStatistic( n11=>$n11,
\&                                      n1p=>$n1p,
\&                                      np1=>$np1,
\&                                      npp=>$npp);
.Ve
.PP
.Vb 8
\&  if( ($errorCode = getErrorCode()))
\&  {
\&    print STDERR $errorCode." - ".getErrorMessage();
\&  }
\&  else
\&  {
\&    print getStatisticName."value for bigram is ".$left_value;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a framework for the naive implementation of the
fishers exact tests. That is the implementation does not have any
optimizations for performance. This will compute the factorials for
the hypergeometric probabilities using direct multiplications.
.PP
This measure should be used if you need exact values without any
rounding errors, and you are not worried about the performance of
the measure, otherwise use the implementations under the
Text::NSP::Measures::2D::Fisher module.
.PP
To use this implementation, you will have to specify the entire
module name. Usage:
.PP
statistic.pl Text::NSP::Measures::Fisher2::left dest.txt source.cnt
.PP
Assume that the frequency count data associated with a bigram
<word1><word2> is stored in a 2x2 contingency table:
.PP
.Vb 5
\&          word2   ~word2
\&  word1    n11      n12 | n1p
\& ~word1    n21      n22 | n2p
\&           --------------
\&           np1      np2   npp
.Ve
.PP
where n11 is the number of times <word1><word2> occur together, and
n12 is the number of times <word1> occurs with some word other than
word2, and n1p is the number of times in total that word1 occurs as
the first word in a bigram.
.PP
The fishers exact tests are calculated by fixing the marginal totals
and computing the hypergeometric probabilities for all the possible
contingency tables,
.PP
A left sided test is calculated by adding the probabilities of all
the possible two by two contingency tables formed by fixing the
marginal totals and changing the value of n11 to less than the given
value. A left sided Fisher's Exact Test tells us how likely it is to
randomly sample a table where n11 is less than observed. In other words,
it tells us how likely it is to sample an observation where the two words
are less dependent than currently observed.
.PP
A right sided test is calculated by adding the probabilities of all
the possible two by two contingency tables formed by fixing the
marginal totals and changing the value of n11 to greater than or
equal to the given value. A right sided Fisher's Exact Test tells us
how likely it is to randomly sample a table where n11 is greater
than observed. In other words, it tells us how likely it is to sample
an observation where the two words are more dependent than currently
observed.
.PP
A two-tailed fishers test is calculated by adding the probabilities of
all the contingency tables with probabilities less than the probability
of the observed table. The two-tailed fishers test tells us how likely
it would be to observe an contingency table which is less probable than
the current table.
.Sh "Methods"
.IX Subsection "Methods"
.IP "\fIgetValues()\fR \- This method calls the \fIcomputeObservedValues()\fR and the \fIcomputeExpectedValues()\fR methods to compute the observed and marginal total values. It checks these values for any errors that might cause the Fishers Exact test measures to fail." 4
.IX Item "getValues() - This method calls the computeObservedValues() and the computeExpectedValues() methods to compute the observed and marginal total values. It checks these values for any errors that might cause the Fishers Exact test measures to fail."
\&\s-1INPUT\s0 \s-1PARAMS\s0  : \f(CW$count_values\fR       .. Reference of an array containing
                                       the count values computed by the
                                       count.pl program.
.Sp
\&\s-1RETURN\s0 \s-1VALUES\s0 : 1/undef           ..returns '1' to indicate success
                                    and an undefined(\s-1NULL\s0) value to indicate
                                    failure.
.IP "\fIcomputeDistribution()\fR \- This method calculates the probabilities for all the possible tables" 4
.IX Item "computeDistribution() - This method calculates the probabilities for all the possible tables"
\&\s-1INPUT\s0 \s-1PARAMS\s0  : \f(CW$n11_start\fR          .. the value for the cell 1,1 in the first contingency
                                       table
                \f(CW$final_limit\fR        .. the value of cell 1,1 in the last contingency table
                                       for which we have to compute the probability.
.Sp
\&\s-1RETURN\s0 \s-1VALUES\s0 : \f(CW$probability\fR        .. Reference to a hash containing hypergeometric
                                       probabilities for all the possible contingency
                                       tables
.SH "AUTHOR"
.IX Header "AUTHOR"
Ted Pedersen,                University of Minnesota Duluth
                             <tpederse@d.umn.edu>
.PP
Satanjeev Banerjee,          Carnegie Mellon University
                             <satanjeev@cmu.edu>
.PP
Amruta Purandare,            University of Pittsburgh
                             <amruta@cs.pitt.edu>
.PP
Bridget Thomson\-McInnes,     University of Minnesota Twin Cities
                             <bthompson@d.umn.edu>
.PP
Saiyam Kohli,                University of Minnesota Duluth
                             <kohli003@d.umn.edu>
.SH "HISTORY"
.IX Header "HISTORY"
Last updated: \f(CW$Id:\fR Fisher2.pm,v 1.11 2008/03/26 17:18:26 tpederse Exp $
.SH "BUGS"
.IX Header "BUGS"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://groups.yahoo.com/group/ngram/>
.PP
<http://www.d.umn.edu/~tpederse/nsp.html>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-2006, Ted Pedersen, Satanjeev Banerjee, Amruta
Purandare, Bridget Thomson-McInnes and Saiyam Kohli
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.
.PP
This program is distributed in the hope that it will be useful, but
\&\s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0
or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0 General Public License
for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License along
with this program; if not, write to
.PP
.Vb 3
\&    The Free Software Foundation, Inc.,
\&    59 Temple Place - Suite 330,
\&    Boston, MA  02111-1307, USA.
.Ve
.PP
Note: a copy of the \s-1GNU\s0 General Public License is available on the web
at <http://www.gnu.org/licenses/gpl.txt> and is included in this
distribution as \s-1GPL\s0.txt.
