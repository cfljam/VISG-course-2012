.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HUGE-COUNT 1"
.TH HUGE-COUNT 1 "2011-04-01" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
huge\-count.pl \- Count all the bigrams in a huge text without using huge amounts of memory. 
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
huge\-count.pl \-\-tokenlist \-\-split 100 destination-dir input
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Runs count.pl efficiently on large amounts of data by splitting the data into separate files, and counting up each file separately, and then merging them to get overall results. 
.PP
Two output files are created. destination\-dir/huge\-count.output contains 
the bigram counts after applying \-\-remove and \-\-remove. 
destination\-dir/complete\-huge\-count.output provides the bigram counts as 
if no \-\-uremove or \-\-remove cutoff were provided. 
.SH "USAGE"
.IX Header "USAGE"
huge\-count.pl [\s-1OPTIONS\s0] \s-1DESTINATION\s0 [\s-1SOURCE\s0]+
.SH "INPUT"
.IX Header "INPUT"
.Sh "Required Arguments:"
.IX Subsection "Required Arguments:"
\fI[\s-1SOURCE\s0]+\fR
.IX Subsection "[SOURCE]+"
.PP
Input to huge\-count.pl should be a \-
.IP "1. Single plain text file" 4
.IX Item "1. Single plain text file"
Or
.IP "2. Single flat directory containing multiple plain text files" 4
.IX Item "2. Single flat directory containing multiple plain text files"
Or
.IP "3. List of multiple plain text files" 4
.IX Item "3. List of multiple plain text files"
.PP
\fI\s-1DESTINATION\s0\fR
.IX Subsection "DESTINATION"
.PP
A complete path to a writable directory to which huge\-count.pl can write all 
intermediate and final output files. If \s-1DESTINATION\s0 does not exist, 
a new directory is created, otherwise, the current directory is simply used
for writing the output files. 
.PP
\&\s-1NOTE:\s0 If \s-1DESTINATION\s0 already exists and if the names of some of the existing 
files in \s-1DESTINATION\s0 clash with the names of the output files created by 
huge\-count, these files will be over-written w/o prompting user. 
.PP
\fI\-\-tokenlist\fR
.IX Subsection "--tokenlist"
.PP
This parameter is required. huge-count will call count.pl and print out all 
the bigrams count.pl can find out.
.Sh "Optional Arguments:"
.IX Subsection "Optional Arguments:"
\-\-split N
.IX Subsection "--split N"
.PP
This parameter is required. huge-count will divide the output bigrams
tokenlist generated by count.pl, sort on each part and recombine the bigram 
counts from all these intermediate result files into a single bigram output 
that shows bigram counts in \s-1SOURCE\s0.
.PP
Each part created with \-\-split N will contain N lines. Value of N should be 
chosen such that huge\-sort.pl can be efficiently run on any part containing 
N lines from the file contains all bigrams file. 
.PP
We suggest that N is equal to the number of \s-1KB\s0 of memory you have. If the 
computer has 8 \s-1GB\s0 \s-1RAM\s0, which is 8,000,000 \s-1KB\s0, N should be set to 8000000. If
N is set too small, split output file suffixes exhausted.  
.PP
\-\-token \s-1TOKENFILE\s0
.IX Subsection "--token TOKENFILE"
.PP
Specify a file containing Perl regular expressions that define the tokenization
scheme for counting. This will be provided to count.pl's \-\-token option.
.PP
\&\-\-nontoken \s-1NOTOKENFILE\s0
.PP
Specify a file containing Perl regular expressions of non-token sequences 
that are removed prior to tokenization. This will be provided to the 
count.pl's \-\-nontoken option.
.PP
\&\-\-stop \s-1STOPFILE\s0
.PP
Specify a file of Perl regex/s containing the list of stop words to be 
omitted from the output \s-1BIGRAMS\s0. Stop list can be used in two modes \-
.PP
\&\s-1AND\s0 mode declared with '@stop.mode = \s-1AND\s0' on the 1st line of the \s-1STOPFILE\s0
.PP
or
.PP
\&\s-1OR\s0 mode declared using '@stop.mode = \s-1OR\s0' on the 1st line of the \s-1STOPFILE\s0.
.PP
In \s-1AND\s0 mode, bigrams whose both constituent words are stop words are removed
while, in \s-1OR\s0 mode, bigrams whose either or both constituent words are 
stopwords are removed from the output.
.PP
\-\-window W
.IX Subsection "--window W"
.PP
Tokens appearing within W positions from each other (with at most W\-2 
intervening words) will form bigrams. Same as count.pl's \-\-window option.
.PP
\-\-remove L
.IX Subsection "--remove L"
.PP
Bigrams with counts less than L in the entire \s-1SOURCE\s0 data are removed from
the sample. The counts of the removed bigrams are not counted in any 
marginal totals. This has same effect as count.pl's \-\-remove option.
.PP
\-\-uremove L
.IX Subsection "--uremove L"
.PP
Bigrams with counts more than L in the entire \s-1SOURCE\s0 data are removed from
the sample. The counts of the removed bigrams are not counted in any 
marginal totals. This has same effect as count.pl's \-\-uremove option.
.PP
\-\-frequency F
.IX Subsection "--frequency F"
.PP
Bigrams with counts less than F in the entire \s-1SOURCE\s0 are not displayed. 
The counts of the skipped bigrams \s-1ARE\s0 counted in the marginal totals. In other
words, \-\-frequency in huge\-count.pl has same effect as the count.pl's 
\&\-\-frequency option.
.PP
\-\-ufrequency F
.IX Subsection "--ufrequency F"
.PP
Bigrams with counts more than F in the entire \s-1SOURCE\s0 are not displayed. 
The counts of the skipped bigrams \s-1ARE\s0 counted in the marginal totals. In other
words, \-\-frequency in huge\-count.pl has same effect as the count.pl's 
\&\-\-ufrequency option.
.PP
\-\-newLine
.IX Subsection "--newLine"
.PP
Switches \s-1ON\s0 the \-\-newLine option in count.pl. This will prevent bigrams from 
spanning across the lines.
.PP
\fIOther Options :\fR
.IX Subsection "Other Options :"
.PP
\-\-help
.IX Subsection "--help"
.PP
Displays this message.
.PP
\-\-version
.IX Subsection "--version"
.PP
Displays the version information.
.SH "PROGRAM LOGIC"
.IX Header "PROGRAM LOGIC"
.IP "* \s-1STEP\s0 1" 4
.IX Item "STEP 1"
.Vb 3
\& # create output dir
\& if(!-e DESTINATION) then 
\& mkdir DESTINATION;
.Ve
.IP "* \s-1STEP\s0 2" 4
.IX Item "STEP 2"
.RS 4
.PD 0
.IP "1. If \s-1SOURCE\s0 is a single plain file \-" 3
.IX Item "1. If SOURCE is a single plain file -"
.PD
huge\-count.pl with \-\-tokenlist option call count.pl and run on the single 
plain file and print out all bigrams into one file.  The count outputs are 
also created in \s-1DESTINATION\s0.
.IP "2. \s-1SOURCE\s0 is a single flat directory containing multiple plain files \-" 3
.IX Item "2. SOURCE is a single flat directory containing multiple plain files -"
huge\-count.pl with \-\-tokenlist option call count.pl and run on each file 
present in the \s-1SOURCE\s0 directory. All files in \s-1SOURCE\s0 are treated as the 
data files. If \s-1SOURCE\s0 contains sub\-directories, these are simply skipped. 
Intermediate bigram outputs are written in \s-1DESTINATION\s0.
.IP "3. \s-1SOURCE\s0 is a list of multiple plain files \-" 3
.IX Item "3. SOURCE is a list of multiple plain files -"
If #arg > 2, all arguments specified after the first argument are considered
as the \s-1SOURCE\s0 file names. count.pl is separately run on each of the \s-1SOURCE\s0 
files specified by argv[1], argv[2], ... argv[n] (skipping argv[0] which 
should be \s-1DESTINATION\s0). Intermediate results are created in \s-1DESTINATION\s0.
.RE
.RS 4
.Sp
In summary, a large datafile can be provided to huge-count in the form of 
.Sp
a. A single plain file 
.Sp
b. A directory containing several plain files
.Sp
c. Multiple plain files directly specified as command line arguments
.Sp
In all these cases, count.pl with \-\-tokenlist is separately run on \s-1SOURCE\s0 
files or parts of \s-1SOURCE\s0 file and intermediate results are written in 
\&\s-1DESTINATION\s0 dir.
.RE
.IP "* \s-1STEP\s0 3" 4
.IX Item "STEP 3"
Split the output file generate by count.pl with \-\-tokenlist  into smaller 
files by the number of bigrams N.
.IP "* \s-1STEP\s0 4" 4
.IX Item "STEP 4"
huge\-sort.pl counts the unique bigrams and sort them in alphabetic order. 
.IP "* \s-1STEP\s0 5" 4
.IX Item "STEP 5"
huge\-merge.pl merge the bigrams of each sorted bigrams file. 
.SH "OUTPUT"
.IX Header "OUTPUT"
After huge-count finishes successfully, \s-1DESTINATION\s0 will contain \-
.IP "* Final bigram count file (huge\-count.output) showing bigram counts in the entire \s-1SOURCE\s0 after \-\-remove and \-\-uremove applied." 4
.IX Item "Final bigram count file (huge-count.output) showing bigram counts in the entire SOURCE after --remove and --uremove applied."
.PD 0
.IP "* Final bigram count file (complete\-huge\-count.output) showing bigram counts in the entire \s-1SOURCE\s0 without \-\-remove and \-\-uremove." 4
.IX Item "Final bigram count file (complete-huge-count.output) showing bigram counts in the entire SOURCE without --remove and --uremove."
.PD
.SH "BUGS"
.IX Header "BUGS"
huge\-count.pl doesn't consider bigrams at file boundaries. In other words,
the result of count.pl and huge\-count.pl on the same data file will
differ if \-\-newLine is not used, in that, huge\-count.pl runs count.pl
on multiple files separately and thus looses the track of the bigrams 
on file boundaries. With \-\-window not specified, there will be loss 
of one bigram at each file boundary while its W bigrams with \-\-window W. 
.PP
Functionality of huge-count with \-\-tokenlist is same as count only if 
\&\-\-newLine is used and all files start and end on sentence boundaries.
In other words, there should not be any sentence breaks at the start or 
end of any file given to huge\-count.
.SH "AUTHOR"
.IX Header "AUTHOR"
Amruta Purandare, University of Minnesota, Duluth
.PP
Ted Pedersen, University of Minnesota, Duluth
tpederse at umn.edu
.PP
Ying Liu, University of Minnesota, Twin Cities
liux0395 at umn.edu
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004\-2010, Amruta Purandare, Ted Pedersen, and Ying Liu
.PP
This program is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.
.PP
This program is distributed in the hope that it will be useful, but \s-1WITHOUT\s0
\&\s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0
\&\s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. See the \s-1GNU\s0 General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License along with
this program; if not, write to
.PP
The Free Software Foundation, Inc.,
59 Temple Place \- Suite 330,
Boston, \s-1MA\s0  02111\-1307, \s-1USA\s0.
